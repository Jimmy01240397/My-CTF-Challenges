#define _GNU_SOURCE
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <signal.h>
#include <pthread.h>
#include <stdbool.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/ioctl.h>
#include <linux/if.h>
#include <linux/if_tun.h>
#include <linux/rtnetlink.h>
#include <linux/ip.h>
#include <linux/ipv6.h>
#include <linux/icmp.h>
#include <netinet/in.h>
#include <sys/ioctl.h>

/*---------------- Configuration ---------------- */
#define PINGLEN 5
#define BACKLOG 16
#define MTU 1500
#define BUF_SIZE MTU
#define MAX_CMD_LEN 256

/*---------------- TUN helpers ----------------------------------------- */
static int create_tun(char *name) {
    struct ifreq ifr = {
        0
    };
    int fd = open("/dev/net/tun", O_RDWR);
    if (fd < 0) {
        perror("open tun");
        exit(1);
    }
    ifr.ifr_flags = IFF_TUN | IFF_NO_PI;
    if (ioctl(fd, TUNSETIFF, & ifr) < 0) {
        perror("TUNSETIFF");
        exit(1);
    }
    strncpy(name, ifr.ifr_name, IFNAMSIZ);
    return fd;
}

/* ------------------------------------------------------------------ */
/*  Netlink helpers                                                    */
/* ------------------------------------------------------------------ */
#define NLMSG_TAIL(nmsg) ((struct rtattr *)(((char *)(nmsg)) + NLMSG_ALIGN((nmsg)->nlmsg_len)))
static void addattr_l(struct nlmsghdr *n, size_t maxlen, int type, const void *data, size_t alen) {
    size_t len = RTA_LENGTH(alen);
    if (NLMSG_ALIGN(n->nlmsg_len) + RTA_ALIGN(len) > maxlen)
    {
        fprintf(stderr,"addattr overflow\n");
        exit(EXIT_FAILURE);
    }
    struct rtattr *rta = NLMSG_TAIL(n);
    rta->rta_type = type;
    rta->rta_len = len;
    memcpy(RTA_DATA(rta), data, alen);
    n->nlmsg_len = NLMSG_ALIGN(n->nlmsg_len) + RTA_ALIGN(len);
}
static int nl_send(int fd, struct nlmsghdr *nlh) {
    struct sockaddr_nl sa = { .nl_family = AF_NETLINK }; 
    return sendto(fd, nlh, nlh->nlmsg_len, 0, (struct sockaddr *)&sa, sizeof(sa));
}

static void configure_tun_ip(const char *ifn, struct in_addr l, struct in_addr p) {
    int ifidx = if_nametoindex(ifn);
    if (!ifidx)
    {
        perror("if_nametoindex");
        return;
    }
    int fd = socket(AF_NETLINK, SOCK_RAW|SOCK_CLOEXEC, NETLINK_ROUTE);
    if (fd < 0)
    {
        perror("netlink");
        return;
    }

    /* ---------- set MTU & IFF_UP ---------- */
    struct { 
        struct nlmsghdr nlh;
        struct ifinfomsg ifi;
        char buf[64];
    } req1 = {0};
    req1.nlh.nlmsg_len   = NLMSG_LENGTH(sizeof(struct ifinfomsg));
    req1.nlh.nlmsg_type  = RTM_NEWLINK;
    req1.nlh.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
    req1.ifi.ifi_family  = AF_UNSPEC;
    req1.ifi.ifi_index   = ifidx;
    req1.ifi.ifi_change  = IFF_UP;
    req1.ifi.ifi_flags   = IFF_UP;
    uint32_t mtu = MTU;
    addattr_l(&req1.nlh, sizeof(req1), IFLA_MTU, &mtu, sizeof(mtu));
    nl_send(fd, &req1.nlh);

    /* ---------- add /32 addr with peer ---------- */
    struct {
        struct nlmsghdr nlh;
        struct ifaddrmsg ifa;
        char buf[64];
    } req2 = {0};
    req2.nlh.nlmsg_len   = NLMSG_LENGTH(sizeof(struct ifaddrmsg));
    req2.nlh.nlmsg_type  = RTM_NEWADDR;
    req2.nlh.nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE | NLM_F_EXCL | NLM_F_ACK;
    req2.ifa.ifa_family  = AF_INET;
    req2.ifa.ifa_prefixlen = 32;
    req2.ifa.ifa_scope   = RT_SCOPE_LINK;
    req2.ifa.ifa_index   = ifidx;
    addattr_l(&req2.nlh, sizeof(req2), IFA_LOCAL,   &l.s_addr, sizeof(l.s_addr));
    addattr_l(&req2.nlh, sizeof(req2), IFA_ADDRESS, &p.s_addr,  sizeof(p.s_addr));
    nl_send(fd, &req2.nlh);

    close(fd);
    char a[INET_ADDRSTRLEN], b[INET_ADDRSTRLEN];
    inet_ntop(AF_INET, &l, a, sizeof a);
    inet_ntop(AF_INET, &p, b, sizeof b);
    printf("[+] %s %s<->%s\n", ifn, a, b);
}

static ssize_t readstreamsock(const uint32_t fd, const uint8_t *buf, ssize_t size) {
    ssize_t tmpn = 0, n = 0;
    while(size > 0) {
        tmpn = read(fd, buf + n, size);
        if (tmpn <= 0) break;
        n += tmpn;
        size -= tmpn;
    }
    if (size > 0) return 0;
    return n;
}

/*---------------- Main ------------------------------------------------- */
int main(int argc, char *argv[]) {
    if (argc <= 2) {
        fprintf(stderr, "usage: %s <host> [PORT]\n", argv[0]);
        return 1;
    }

    const char *ip = argv[1];
    uint16_t port = atoi(argv[2]);

    int sockfd;
    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        perror("socket() failed");
        return 1;
    }
    struct sockaddr_in server_addr = {0};
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(port);
    if (inet_pton(AF_INET, ip, &server_addr.sin_addr) < 0) {
        perror("inet_pton() failed");
        close(sockfd);
        return 1;
    }

    if (connect(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
        perror("connect() failed");
        close(sockfd);
        return 1;
    }
    char buf[BUF_SIZE];
    ssize_t n = read(sockfd, buf, BUF_SIZE);
    struct iphdr *tunip = (struct iphdr *)buf;

    struct in_addr laddr, paddr;
    laddr.s_addr = tunip->daddr;
    paddr.s_addr = tunip->saddr;

    char ifname[IFNAMSIZ];
    int tunfd = create_tun(ifname);
    configure_tun_ip(ifname, laddr, paddr);
    
    fd_set fds;
    int m = (sockfd > tunfd ? sockfd : tunfd) + 1;
    fflush(stdout);
    fflush(stderr);
    while (1) {
        FD_ZERO(&fds);
        FD_SET(sockfd, &fds);
        FD_SET(tunfd, &fds);
        int r = select(m, &fds, NULL, NULL, NULL);
        if (r < 0) {
            if (errno == EINTR) continue;
            break;
        }
        if (FD_ISSET(sockfd, & fds)) {
            ssize_t tmpn = readstreamsock(sockfd, buf, sizeof(struct iphdr));
            if (tmpn <= 0) break;
            ssize_t n = tmpn;
            struct iphdr *iphead = buf;
            struct ipv6hdr *ip6head = buf;
            ssize_t payloadlen = 0;
            switch(iphead->version) {
                case 4:
                    payloadlen = ntohs(iphead->tot_len) - sizeof(struct iphdr);
                    break;
                case 6:
                    payloadlen = ntohs(ip6head->payload_len) + (sizeof(struct ipv6hdr) - sizeof(struct iphdr));
                    break;
                default:
                    continue;
            }
            if (sizeof(struct iphdr) + payloadlen > BUF_SIZE) continue;
            tmpn = readstreamsock(sockfd, buf + n, payloadlen);
            if (tmpn <= 0) break;
            n += tmpn;
            ssize_t tmp = write(tunfd, buf, n);
        }
        if (FD_ISSET(tunfd, & fds)) {
            n = read(tunfd, buf, BUF_SIZE);
            if (n <= 0) break;
            if (write(sockfd, buf, n) != n) break;
        }
        fflush(stdout);
        fflush(stderr);
    }
    printf("[-] close %s\n", ifname);
    close(sockfd);
    close(tunfd);
    puts("bye");
    fflush(stdout);
    fflush(stderr);
    return 0;
}
